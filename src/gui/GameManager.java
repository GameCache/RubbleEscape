package gui;

import game.Game;
import gui.title.TitleScreen;
import java.applet.Applet;
import java.applet.AudioClip;
import java.awt.Graphics;
import java.awt.Image;
import javax.imageio.ImageIO;
import javax.swing.JPanel;

/**
 * Manages the state of the program and runs the game.
 * 
 * @author Jesse Brent
 * @version 1.0, 10/01/10
 */
public final class GameManager extends JPanel implements Runnable {
	
	/** Serialization field generated by Eclipse. */
	private static final long serialVersionUID = 2763848755825850054L;
	
	/**
	 * Possible states of the game.
	 * 
	 * @author Jesse Brent
	 * @version 1.0, 10/03/10
	 */
	private static enum GameState {
		/** A state of the game. */
		TITLE, GAME, GAMEOVER;
	}
	
	/** Interval in which the code is executed, in milliseconds. */
	private static final int UPDATE_SPEED = 20;
	
	/** The title screen for the game. */
	private final transient TitleScreen title;
	
	/** The gameover screen for the game. */
	private final transient GameoverScreen gameover;
	
	/** The game being played. */
	private final transient Game game;
	
	/** The state of the game. */
	private GameState state;
	
	/** Flags used to ensure thread safety with repaint and performance. */
	private boolean busy, painting;
	
	/**
	 * Constructs the GameManager to handle manage the game.
	 */
	public GameManager() {
		super();
		
		game = new Game();
		title = new TitleScreen();
		gameover = new GameoverScreen();
		
		busy = true;
		painting = false;
		state = GameState.TITLE;
	}
	
	/*
	 * {@inheritDoc}
	 * 
	 * @see java.lang.Runnable#run()
	 */
	@Override
	public void run() {
		title.reset();
		state = GameState.TITLE;
		this.addKeyListener(title);
		
		while(!Thread.interrupted()) {
			switch(state) {
				case TITLE: {
					title.step();
					if(title.canPlayGame()) {
						this.removeKeyListener(title);
						this.addKeyListener(game.getKeyListener());
						title.reset();
						game.reset();
						game.start();
						state = GameState.GAME;
					}
					break;
				}
					
				case GAME: {
					game.step();
					if(!game.isAlive()) {
						this.removeKeyListener(game.getKeyListener());
						this.addKeyListener(gameover);
						gameover.reset();
						game.stop();
						state = GameState.GAMEOVER;
					}
					break;
				}
					
				case GAMEOVER: {
					game.step();
					if(gameover.canReturnTitle()) {
						this.removeKeyListener(gameover);
						this.addKeyListener(title);
						title.reset();
						state = GameState.TITLE;
					} else if(gameover.canRestartGame()) {
						this.removeKeyListener(gameover);
						this.addKeyListener(game.getKeyListener());
						game.reset();
						game.start();
						state = GameState.GAME;
					}
					break;
				}
					
				default: {
					break;
				}
			}
			
			busy = false;
			repaint();
			delay(UPDATE_SPEED);
			while(painting) {
				delay(1);
			}
			busy = true;
		}
		
		game.stop();
		game.reset();
		title.reset();
		gameover.reset();
		this.removeKeyListener(title);
		this.removeKeyListener(game.getKeyListener());
		this.removeKeyListener(gameover);
	}
	
	/*
	 * Draws the graphics for the applet.
	 * 
	 * {@inheritDoc}
	 * 
	 * @see java.awt.Container#paint(java.awt.Graphics)
	 */
	@Override
	public void paint(Graphics g) {
		while(busy) {
			delay(1);
		}
		painting = true;
		
		switch(state) {
			case TITLE: {
				title.paint(g);
				break;
			}
			case GAME: {
				game.paint(g);
				break;
			}
			case GAMEOVER: {
				game.paint(g);
				gameover.paint(g);
				break;
			}
			default: {
				break;
			}
		}
		
		painting = false;
	}
	
	/**
	 * Pauses calculations by putting the thread to sleep.
	 * 
	 * @param timeToSleep
	 *            Milliseconds for the thread to sleep.
	 */
	private static void delay(int timeToSleep) {
		try {
			Thread.sleep(timeToSleep);
		} catch(InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
	
	/**
	 * Loads an image from the '/resources/graphics/' location. Returns null if the image cannot be
	 * found or retrieved.
	 * 
	 * @param imageName
	 *            The name of the image.
	 * @return The image.
	 */
	public static Image loadImage(String imageName) {
		try {
			return ImageIO.read(GameManager.class.getResource("/resources/graphics/" + imageName));
		} catch(Exception error) {
			return null;
		}
	}
	
	/**
	 * Loads a sound from the '/resources/music/' location.
	 * 
	 * @param soundName
	 *            The name of the sound.
	 * @return The sound.
	 */
	public static AudioClip loadSound(String soundName) {
		return Applet.newAudioClip(GameManager.class.getResource("/resources/music/" + soundName));
	}
	
}
